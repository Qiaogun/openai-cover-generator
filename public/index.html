<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>动态封面生成器</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: Inter, "PingFang SC", "Microsoft YaHei", sans-serif;
      background: #06070b;
      color: #e8eaf3;
      display: grid;
      grid-template-columns: 320px 1fr;
    }
    aside {
      border-right: 1px solid rgba(255,255,255,0.12);
      padding: 20px;
      background: linear-gradient(180deg, rgba(18,22,33,0.95), rgba(8,10,17,0.95));
      overflow: auto;
    }
    h1 { font-size: 20px; margin: 0 0 6px; }
    p { margin: 0 0 16px; color: #aeb4cc; font-size: 13px; }
    .control { margin-bottom: 14px; }
    .control label {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      margin-bottom: 6px;
      color: #d6daf1;
    }
    input[type="range"], select {
      width: 100%;
      accent-color: #5f8cff;
      background: transparent;
    }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    button {
      width: 100%;
      border: none;
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 4px;
      cursor: pointer;
      color: #fff;
      font-weight: 600;
      background: linear-gradient(90deg, #5f8cff, #8c64ff);
    }
    main {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .canvas-wrap {
      width: min(100%, 1080px);
      aspect-ratio: 16/9;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 20px 80px rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      background: #0b1022;
    }
    canvas { width: 100%; height: 100%; display: block; }
    @media (max-width: 980px) {
      body { grid-template-columns: 1fr; }
      aside { border-right: 0; border-bottom: 1px solid rgba(255,255,255,0.12); }
      .canvas-wrap { aspect-ratio: 4 / 3; }
    }
  </style>
</head>
<body>
  <aside>
    <h1>动态封面生成器</h1>
    <p>可实时调节颜色范围、模糊程度、透明度及径向叠加参数（内置好看配色方案）。</p>

    <div class="row">
      <div class="control">
        <label for="hueMin">主色相最小值 <span id="hueMinV">12</span></label>
        <input id="hueMin" type="range" min="0" max="360" value="12" />
      </div>
      <div class="control">
        <label for="hueMax">主色相最大值 <span id="hueMaxV">208</span></label>
        <input id="hueMax" type="range" min="0" max="360" value="208" />
      </div>
    </div>

    <div class="control">
      <label for="blur">模糊程度 <span id="blurV">82</span></label>
      <input id="blur" type="range" min="10" max="200" value="82" />
    </div>

    <div class="control">
      <label for="opacity">透明度 <span id="opacityV">0.62</span></label>
      <input id="opacity" type="range" min="0.1" max="1" step="0.01" value="0.62" />
    </div>

    <div class="control">
      <label for="speed">动画速度 <span id="speedV">0.55</span></label>
      <input id="speed" type="range" min="0.1" max="2" step="0.05" value="0.55" />
    </div>

    <div class="control">
      <label for="blobCount">径向图层数量 <span id="blobCountV">6</span></label>
      <input id="blobCount" type="range" min="2" max="12" value="6" />
    </div>

    <div class="control">
      <label for="saturation">饱和度 <span id="saturationV">88</span></label>
      <input id="saturation" type="range" min="35" max="100" value="88" />
    </div>

    <button id="randomizeBtn">随机好看参数</button>
    <button id="downloadBtn">导出 PNG</button>
  </aside>

  <main>
    <div class="canvas-wrap">
      <canvas id="coverCanvas" width="1600" height="900"></canvas>
    </div>
  </main>

  <script>
    const canvas = document.getElementById('coverCanvas');
    const ctx = canvas.getContext('2d');
    const RADIAL_PRESETS = [
      { palette: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'], hueMin: 8, hueMax: 208, blur: [70, 120], opacity: [0.48, 0.76], saturation: [78, 96], layers: [5, 9], speed: [0.35, 0.95] },
      { palette: ['#6C5CE7', '#A29BFE', '#FD79A8', '#FDCB6E', '#6C5CE7'], hueMin: 260, hueMax: 345, blur: [70, 125], opacity: [0.45, 0.72], saturation: [74, 96], layers: [5, 8], speed: [0.3, 0.9] },
      { palette: ['#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43'], hueMin: 190, hueMax: 320, blur: [65, 115], opacity: [0.46, 0.75], saturation: [82, 100], layers: [5, 9], speed: [0.35, 1.05] },
      { palette: ['#F8B500', '#FF6B6B', '#FF8E53', '#C44569', '#574B90'], hueMin: 18, hueMax: 300, blur: [72, 128], opacity: [0.45, 0.72], saturation: [76, 96], layers: [5, 8], speed: [0.3, 0.95] },
      { palette: ['#08D9D6', '#252A34', '#FF2E63', '#EAEAEA', '#F9F9F9'], hueMin: 170, hueMax: 350, blur: [75, 135], opacity: [0.4, 0.68], saturation: [68, 92], layers: [4, 7], speed: [0.25, 0.85] },
    ];

    const controls = {
      hueMin: document.getElementById('hueMin'),
      hueMax: document.getElementById('hueMax'),
      blur: document.getElementById('blur'),
      opacity: document.getElementById('opacity'),
      speed: document.getElementById('speed'),
      blobCount: document.getElementById('blobCount'),
      saturation: document.getElementById('saturation'),
    };

    const labels = {
      hueMin: document.getElementById('hueMinV'),
      hueMax: document.getElementById('hueMaxV'),
      blur: document.getElementById('blurV'),
      opacity: document.getElementById('opacityV'),
      speed: document.getElementById('speedV'),
      blobCount: document.getElementById('blobCountV'),
      saturation: document.getElementById('saturationV'),
    };

    let layers = [];
    let activePreset = RADIAL_PRESETS[0];
    let activePaletteHues = [];
    let animationId;

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function hexToHue(hex) {
      const cleaned = hex.replace('#', '');
      const r = parseInt(cleaned.slice(0, 2), 16) / 255;
      const g = parseInt(cleaned.slice(2, 4), 16) / 255;
      const b = parseInt(cleaned.slice(4, 6), 16) / 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const d = max - min;
      if (d === 0) return 0;
      let h = 0;
      if (max === r) h = ((g - b) / d) % 6;
      else if (max === g) h = (b - r) / d + 2;
      else h = (r - g) / d + 4;
      return (h * 60 + 360) % 360;
    }

    function setActivePreset(preset) {
      activePreset = preset;
      activePaletteHues = preset.palette.map(hexToHue);
    }

    function pickPreset() {
      return RADIAL_PRESETS[Math.floor(rand(0, RADIAL_PRESETS.length))];
    }

    function createLayer(index) {
      const hueMin = Number(controls.hueMin.value);
      const hueMax = Number(controls.hueMax.value);
      const hueRangeMin = Math.min(hueMin, hueMax);
      const hueRangeMax = Math.max(hueMin, hueMax);
      const rangeHue = rand(hueRangeMin, hueRangeMax);
      const paletteHue = activePaletteHues.length
        ? activePaletteHues[Math.floor(rand(0, activePaletteHues.length))]
        : rangeHue;
      const hue = (paletteHue * 0.72 + rangeHue * 0.28 + rand(-12, 12) + 360) % 360;

      return {
        x: rand(0.1, 0.9),
        y: rand(0.12, 0.88),
        radiusX: rand(0.22, 0.52),
        radiusY: rand(0.18, 0.46),
        hue,
        phase: rand(0, Math.PI * 2),
        orbitX: rand(0.02, 0.09),
        orbitY: rand(0.02, 0.09),
        frequency: rand(0.2, 1.2),
        rotation: rand(0, 360),
        rotationSpeed: rand(-16, 16),
        skewX: rand(-14, 14),
        skewY: rand(-14, 14),
        pulse: rand(0.88, 1.18),
        seed: index + Math.random() * 100,
      };
    }

    function regenerateLayers() {
      const count = Number(controls.blobCount.value);
      layers = Array.from({ length: count }, (_, i) => createLayer(i));
    }

    function updateLabelValues() {
      Object.keys(controls).forEach((key) => {
        labels[key].textContent = controls[key].value;
      });
    }

    function drawBackground(t) {
      const hueMin = Number(controls.hueMin.value);
      const hueMax = Number(controls.hueMax.value);
      const centerHue = (Math.min(hueMin, hueMax) + Math.max(hueMin, hueMax)) / 2;
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, `hsl(${(centerHue - 16 + 360) % 360}, 38%, 96%)`);
      gradient.addColorStop(1, `hsl(${(centerHue + 18) % 360}, 46%, 93%)`);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const pulse = (Math.sin(t * 0.0005) + 1) / 2;
      ctx.fillStyle = `rgba(255,255,255,${0.04 + pulse * 0.02})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawLayers(t) {
      const blur = Number(controls.blur.value);
      const opacity = Number(controls.opacity.value);
      const saturation = Number(controls.saturation.value);
      const speed = Number(controls.speed.value);
      const time = t * 0.001 * speed;
      const minSide = Math.min(canvas.width, canvas.height);

      ctx.globalCompositeOperation = 'source-over';
      ctx.filter = `blur(${blur}px)`;

      layers.forEach((layer) => {
        const x = (layer.x + Math.sin(time * layer.frequency + layer.phase) * layer.orbitX) * canvas.width;
        const y = (layer.y + Math.cos(time * (layer.frequency + 0.27) + layer.phase * 1.9) * layer.orbitY) * canvas.height;
        const pulse = layer.pulse + Math.sin(time * (layer.frequency + 0.4) + layer.seed) * 0.1;
        const rx = Math.max(40, layer.radiusX * minSide * pulse);
        const ry = Math.max(40, layer.radiusY * minSide * pulse);
        const rotation = (layer.rotation + time * layer.rotationSpeed * 30) * (Math.PI / 180);

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.transform(1, Math.tan((layer.skewY * Math.PI) / 180), Math.tan((layer.skewX * Math.PI) / 180), 1, 0, 0);
        ctx.scale(rx, ry);

        const radial = ctx.createRadialGradient(0, 0, 0.02, 0, 0, 1);
        radial.addColorStop(0, `hsla(${layer.hue}, ${Math.min(100, saturation + 8)}%, 64%, ${Math.min(1, opacity + 0.15)})`);
        radial.addColorStop(0.5, `hsla(${(layer.hue + 22) % 360}, ${Math.min(100, saturation + 4)}%, 60%, ${opacity * 0.9})`);
        radial.addColorStop(1, `hsla(${(layer.hue + 40) % 360}, ${Math.max(25, saturation - 22)}%, 56%, 0)`);

        ctx.fillStyle = radial;
        ctx.beginPath();
        ctx.arc(0, 0, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      ctx.filter = 'none';
      ctx.globalCompositeOperation = 'source-over';
    }

    function applyPreset(preset, withVariance = true) {
      setActivePreset(preset);
      const vary = (v, amount) => withVariance ? v + rand(-amount, amount) : v;
      const pick = (range) => withVariance ? rand(range[0], range[1]) : (range[0] + range[1]) / 2;
      controls.hueMin.value = Math.max(0, Math.min(360, Math.round(vary(preset.hueMin, 8))));
      controls.hueMax.value = Math.max(0, Math.min(360, Math.round(vary(preset.hueMax, 12))));
      controls.blur.value = Math.round(pick(preset.blur));
      controls.opacity.value = pick(preset.opacity).toFixed(2);
      controls.saturation.value = Math.round(pick(preset.saturation));
      controls.blobCount.value = Math.round(pick(preset.layers));
      controls.speed.value = pick(preset.speed).toFixed(2);
      regenerateLayers();
      updateLabelValues();
    }

    function frame(t) {
      drawBackground(t);
      drawLayers(t);
      animationId = requestAnimationFrame(frame);
    }

    function rerender() {
      updateLabelValues();
      if (animationId) cancelAnimationFrame(animationId);
      frame(performance.now());
    }

    Object.values(controls).forEach((input) => {
      input.addEventListener('input', () => {
        updateLabelValues();
        if (input === controls.blobCount || input === controls.hueMin || input === controls.hueMax) {
          regenerateLayers();
        }
      });
    });

    document.getElementById('randomizeBtn').addEventListener('click', () => {
      applyPreset(pickPreset(), true);
    });

    document.getElementById('downloadBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = `dynamic-cover-${Date.now()}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    applyPreset(RADIAL_PRESETS[0], false);
    rerender();
  </script>
</body>
</html>
